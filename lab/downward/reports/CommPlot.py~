
import logging
import os
import sys
from collections import defaultdict

try:
    import matplotlib
    from matplotlib import figure
    from matplotlib.backends import backend_agg
except ImportError, err:
    logging.warning('matplotlib could not be found: %s' % err)
    logging.warning('You can\'t create any plots on this machine.')

from lab import tools

from downward.reports import PlanningReport
from downward.reports.plot import ProblemPlotReport
from downward.reports.plot import PlotReport

EPSILON = 0.01




class DomainCommPlotReport(ProblemPlotReport):
    """
    For each domain generate a plot for commulative h*/h.
    """
    def __init__(self, get_points=None, **kwargs):
        """
        *get_points* can be a function that takes a **single** run (dictionary
        of properties) and returns the points that should be drawn for this run.
        The return value can be a list of (x,y) coordinates or a dictionary
        mapping category names to lists of (x,y) coordinates, i.e.::

            get_points(run) == [(1, 1), (2, 4), (3, 9)]
            or
            get_points(run) == {'x^2': [(1, 1), (2, 4), (3, 9)],
                                'x^3': [(1, 1), (2, 8), (3, 27)]}

        Internally all coordinates of a category are combined and drawn in the
        same style (e.g. red circles). Returned lists without a category are
        assigned to a default category that does not appear in the legend.

        If get_points is None, *attributes* must contain exactly one attribute.
        Then we will plot the config names on the x-axis and the corresponding
        values for *attribute* on the y-axis. Otherwise *attributes* will be
        ignored and it's up to you to retrieve the y-values from the runs.

        Examples::

            # Plot number of node expansions for all configs.
            ProblemPlotReport(attributes=['expansions'])

            # Compare different ipdb and m&s configurations.
            # configs: 'ipdb-1000', 'ipdb-2000', 'mas-1000', 'mas-2000'
            def config_and_states(run):
                nick, states = run['config_nick'].split('-')
                return {nick: [(states, run.get('expansions'))]}

            PlotReport(attributes=['expansions'], get_points=config_and_states)

        """
        PlotReport.__init__(self, **kwargs)

        

    def get_points(self, run):
        """
        By default plot the configs on the x-axis and the attribute values on
        the y-axis. All values are in the same category.
        """
        return [(run.get('config'), run.get(self.attribute))]

    def _fill_categories(self, runs):
        categories = defaultdict(list)
        for run in runs:
            new_categories = self.get_points(run)
            if isinstance(new_categories, dict):
                for category, points in new_categories.items():
                    categories[category].extend(points)
            elif isinstance(new_categories, (list, tuple)):
                # Implicitly check that this is a list of pairs.
                for x, y in new_categories:
                    categories[None].append((x, y))
            elif new_categories is not None:
                # Allow returning None.
                logging.critical('get_points() returned the wrong format.')
        return categories

    def _prepare_categories(self, categories):
        categories = PlotReport._prepare_categories(self, categories)
        new_categories = {}
        for category, coords in categories.items():
            # Do not include missing values in plot, but reserve spot on x-axis.
            coords = [(x, y) for (x, y) in coords if y is not None]
            # Make sure that values are sorted by x, otherwise the wrong points
            # may be connected.
            coords.sort(key=lambda (x, y): x)
            new_categories[category] = coords
        return new_categories

    def _write_plots(self, directory):
        for (domain, problem), runs in sorted(self.problem_runs.items()):
	    HstarToHRatioAndStatistics._get_commulative_table(self, domain)
            parts = [self.title.lower().replace(' ', '-')] if self.title else []
            if problem.endswith('.pddl'):
                problem = problem[:-len('.pddl')]
            parts += [domain, problem]
            path = os.path.join(directory, '-'.join(parts) + '.' + self.output_format)
            self._write_plot(runs, path)

    def write(self):
        if os.path.isfile(self.outfile):
            logging.critical('outfile must be a directory for this report.')
        tools.makedirs(self.outfile)
        self._write_plots(self.outfile)
